-- Análisis del archivo init_6.sql - Funciones y Triggers Principales

-- ==============================================
-- ARCHIVO: init_6.sql - Funciones y Triggers Principales - ANÁLISIS
-- ==============================================
-- Resumen del Propósito:
-- El archivo init_6.sql implementa la lógica de negocio central a través de funciones y triggers,
-- incluyendo gestión de permisos, cuotas, configuración, operaciones del sistema y procesamiento de embeddings.
-- Este script define funciones de utilidad, sistema de permisos, logging, gestión de cuotas, validación de configuración,
-- procesamiento de embeddings, triggers de validación de cuotas y funciones de mantenimiento/diagnóstico.

-- ---------- SECCIÓN PRELIMINAR: ELIMINACIÓN DE FUNCIONES EXISTENTES - ANÁLISIS ----------
-- OK: Eliminación de funciones existentes (`DROP FUNCTION IF EXISTS ... CASCADE;`) al inicio del script.  Esto es correcto para asegurar una instalación limpia y evitar conflictos con versiones anteriores.  La eliminación en cascada (`CASCADE`) es apropiada para eliminar dependencias (triggers, etc.).

-- ---------- SECCIÓN 1: FUNCIONES BÁSICAS DE UTILIDAD - ANÁLISIS ----------
-- OK: Función `update_modified_column()`: Trigger function para actualizar la columna `updated_at` en tablas.
--  **OK**:  Función trigger simple y eficiente para mantener timestamps de actualización.  Uso de `SECURITY DEFINER SET search_path = public, app, extensions` es correcto para asegurar que la función se ejecuta con los permisos definidos y el `search_path` correcto.
-- OK: Función `increment_link_clicks()`: Incrementa el contador de clics de enlaces de forma concurrente segura.
--  **OK**:  Uso de `PERFORM ... FOR UPDATE` para bloquear explícitamente la fila `public.links` y evitar condiciones de carrera durante el incremento del contador de clics.  Manejo de excepciones con `EXCEPTION WHEN OTHERS THEN ... PERFORM log_system_error(...) ... RETURN NEW;` es robusto, registrando errores sin interrumpir la operación principal (aunque devuelve `NEW` para continuar el trigger, incluso si el contador no se incrementó, lo cual podría ser un comportamiento aceptable para no bloquear la operación principal de clic en el enlace, pero **considerar si devolver `NULL` en lugar de `NEW` podría ser más apropiado para indicar que la operación del trigger no se completó completamente**). `SECURITY DEFINER SET search_path = public, app, extensions` es apropiado.

-- ---------- SECCIÓN 2: FUNCIONES DE PERMISOS Y ROLES - ANÁLISIS ----------
-- OK: Función `is_admin(user_uuid UUID)`: Verifica si un usuario tiene el rol de administrador.
--  **OK**:  Función simple para verificar el rol 'admin' en la tabla `app.user_roles`. Manejo de `NULL` user_uuid y manejo de excepciones con `RAISE WARNING` y retorno de `FALSE` es adecuado. `SECURITY DEFINER SET search_path = public, app, extensions` es correcto.
-- OK: Función `has_permission(user_uuid UUID, permission_name TEXT)`: Verifica si un usuario tiene un permiso específico.
--  **OK**:  Función completa para la verificación de permisos.  Verifica primero si el usuario es administrador (todos los permisos), luego busca el rol del usuario y sus permisos JSONB en `app.user_roles`.  Considera permisos implícitos basados en roles predefinidos ('moderator', 'support', 'developer'). Manejo de parámetros `NULL`, roles no asignados y excepciones con `RAISE WARNING` y retorno de `FALSE` es robusto. `SECURITY DEFINER SET search_path = public, app, extensions` es correcto.  La lógica de permisos basada en roles y permisos específicos en JSONB es flexible.

-- ---------- SECCIÓN 3: SISTEMA DE LOGGING Y ERRORES - ANÁLISIS ----------
-- OK: Función `log_system_error(...)`: Registra errores del sistema en `app.system_errors`.
--  **OK**:  Función de logging robusta y mejorada.  Valida severidad, limita el tamaño del mensaje (`substring(..., 1, 2000)`), añade timestamp al contexto, limita el tamaño del contexto JSONB, inserta el registro de error en `app.system_errors`, y emite `RAISE WARNING` para errores críticos.  Manejo de excepciones (`EXCEPTION WHEN OTHERS THEN ... RAISE WARNING ... RETURN extensions.uuid_generate_v4();`) dentro de la función de logging es crucial para evitar que el logging falle y afecte la operación principal. Retornar un UUID en caso de fallo de logging es una buena práctica para evitar valores nulos. `SECURITY DEFINER SET search_path = public, app, extensions` es correcto. La limitación del tamaño del mensaje y el contexto evita posibles problemas de almacenamiento y rendimiento.

-- ---------- SECCIÓN 4: GESTIÓN DE CUOTAS DE USUARIO - ANÁLISIS ----------
-- OK: Función `check_user_quota(p_user_id UUID, p_quota_type TEXT)`: Verifica si un usuario está dentro de sus límites de cuota para un recurso.
--  **OK**:  Función compleja pero bien estructurada para la gestión de cuotas.  Verifica parámetros de entrada, maneja el caso de administradores (sin cuota), determina la clave de configuración de cuota basada en `p_quota_type`, obtiene la cuota específica del usuario utilizando `get_config_int` (asumiendo que esta función existe y se define en otro archivo - **verificar existencia de `get_config_int` function, potentially in `init_3.sql` or earlier scripts**), maneja cuotas ilimitadas (cuota <= 0), cuenta los recursos actuales del usuario basados en `p_quota_type`, obtiene el año-mes actual, actualiza las métricas de uso mensual en `app.usage_metrics` con bloqueo explícito (`FOR UPDATE`) para concurrencia segura (con desglose diario de uso en JSONB), y finalmente verifica si el usuario está dentro de la cuota.  Manejo de excepciones con `PERFORM log_system_error(...) ... RETURN TRUE;` es similar a `increment_link_clicks()`, permitiendo la operación en caso de error de verificación de cuota para evitar bloqueos (but **consider if returning `FALSE` and raising an exception might be more appropriate to enforce quotas strictly**, depending on business requirements). `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.  El desglose diario de uso en JSONB es útil para analíticas más detalladas.

-- ---------- SECCIÓN 5: VALIDACIÓN Y GESTIÓN DE CONFIGURACIÓN - ANÁLISIS ----------
-- OK: Función `validate_config_value(...)`: Valida el valor de una configuración según su tipo de dato y restricciones.
--  **OK**:  Función de validación robusta.  Verifica `NULL` input, valida valores basados en `p_data_type` ('integer', 'float', 'boolean', 'json', 'text') y restricciones (min/max values, max length for text).  Normaliza valores booleanos.  Emite `RAISE EXCEPTION` con un mensaje descriptivo en caso de validación fallida. `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.  Esta función es reusable y centraliza la lógica de validación de configuraciones.
-- OK: Función `set_user_config(...)`: Establece una configuración específica para un usuario.
--  **OK**:  Función compleja para establecer configuraciones de usuario.  Verifica permisos (admin or `manage_user_configs`), existencia del usuario, existencia de la clave de configuración, editabilidad de la configuración, valida el valor utilizando `validate_config_value()`, verifica si el valor ha cambiado (optimización para evitar actualizaciones innecesarias), inserta o actualiza la configuración en `app.user_config` (`ON CONFLICT ... DO UPDATE`), registra en auditoría (`audit.config_changes`), y registra la acción en el log del sistema.  Usa transacciones explícitas (`BEGIN ... EXCEPTION WHEN OTHERS THEN ... END;`) para garantizar la atomicidad de la operación.  Manejo completo de errores y auditoría. `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.
-- OK: Función `bulk_update_config_by_plan(...)`: Actualiza la configuración para todos los usuarios de un plan específico.
--  **OK**:  Función para actualizaciones masivas de configuración por plan.  Verifica permisos (admin or `manage_subscription_configs`), validez del tipo de plan, existencia de la clave de configuración, valida el valor con `validate_config_value()`, actualiza la configuración del plan en `app.subscription_plan_config` (`ON CONFLICT ... DO UPDATE`), registra en auditoría, y opcionalmente aplica la configuración a todos los usuarios activos del plan (con una advertencia si el número de usuarios afectados es large, suggesting background processing).  Reutiliza `set_user_config()` for applying config to individual users.  Handles errors during individual user config updates gracefully (logging error and continuing to next user).  Uses explicit transactions and comprehensive logging. `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.  The check for a large number of users and suggestion to use background processing is a good practice for performance and stability.
-- OK: Función `reset_user_config_to_plan(...)`: Restablece la configuración de un usuario a los valores predeterminados por su plan.
--  **OK**:  Función para resetear configuraciones de usuario a los valores del plan.  Verifica permisos (admin or `manage_user_configs`), existencia del usuario, obtiene el plan actual del usuario, elimina configuraciones de usuario (either all custom configs or only plan-related configs based on `p_reset_all` parameter), and logs the action.  Uses explicit transactions and error handling. `SECURITY DEFINER SET search_path = public, app, extensions` is correcto. The option to reset all or only plan-related configurations provides flexibility.

-- ---------- SECCIÓN 6: FUNCIONES DE VECTOR EMBEDDING - ANÁLISIS ----------
-- OK: Función `update_vector_dimensions()`: Actualiza las dimensiones de vectores en tablas relevantes after changing `vector_dimension` config.
--  **OK**:  Función para actualizar las vector dimensions across tables.  Retrieves new dimension using `get_vector_dimension()` (again, **verify `get_vector_dimension()` function existence, potentially in `init_4.sql` or earlier**), verifies the existence of `update_vector_fields_to_current_dimension()` (defined in `init_4.sql`), calls `update_vector_fields_to_current_dimension()` to perform the actual update, and logs the action.  Handles errors during dimension update and logging. `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.  This function centralizes the dimension update process and ensures consistency across the vector-related tables.

-- ---------- SECCIÓN 7: TRIGGERS DE VALIDACIÓN DE CUOTA - ANÁLISIS ----------
-- OK: Función trigger `enforce_bot_quota()`: Trigger to enforce bot quota before creating a new bot.
--  **OK**:  Trigger function to enforce bot quota.  Calls `check_user_quota(NEW.user_id, 'bots')` to verify quota. If quota exceeded, logs error using `log_system_error()` and raises `RAISE EXCEPTION` to prevent bot creation.  `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.  This is a standard pattern for quota enforcement triggers.
-- OK: Función trigger `enforce_collection_quota()`: Trigger to enforce document collection quota before creating a new collection.
--  **OK**: Trigger function, similar structure to `enforce_bot_quota()`, enforcing collection quota using `check_user_quota(NEW.user_id, 'collections')`.  Correctly enforces collection quota. `SECURITY DEFINER SET search_path = public, app, extensions` is correcto.

-- ---------- SECCIÓN FINAL:  (SECTION 8 and beyond implied but not fully shown) - ANÁLISIS ----------
-- Review is cut off before reaching section 8 and further triggers but the analysis pattern is clear. Assuming the rest of the file continues with similar triggers (`enforce_document_quota`, `enforce_vector_search_quota`, etc.) and potentially maintenance/diagnostic functions, the analysis approach would remain the same: verify purpose, correctness, security, error handling, and consistency.

-- ==============================================
-- RESUMEN GENERAL DEL ARCHIVO init_6.sql - INCONSISTENCIAS Y SUGERENCIAS
-- ==============================================
-- INCONSISTENCIAS Y SUGERENCIAS:
--  1. **Consistencia in `increment_link_clicks()` and `check_user_quota()` Exception Handling return values**: In `increment_link_clicks()` and `check_user_quota()`, in the `EXCEPTION WHEN OTHERS THEN` block, `RETURN NEW;` and `RETURN TRUE;` are used respectively.  While this allows the main operation to continue despite errors in the trigger or quota check, **consider if returning `NULL` in `increment_link_clicks()` and `FALSE` in `check_user_quota()` and potentially raising an exception in `check_user_quota()` might be more appropriate depending on the desired strictness.  If data integrity and quota enforcement are paramount, preventing the operation and raising an exception would be stronger.**  If the goal is to be lenient and avoid blocking user operations even with minor errors, the current approach is acceptable, but should be documented clearly with a comment explaining this choice.
--  2. **Verify Existence of `get_config_int()` and `get_vector_dimension()` Functions**: The `check_user_quota()` function relies on `get_config_int()`, and `update_vector_dimensions()` relies on `get_vector_dimension()`.  **Ensure these functions are defined in previous scripts (`init_3.sql`, `init_4.sql`, or earlier).  If not defined, these scripts will fail.**  Add dependency checks for these functions at the beginning of `init_6.sql` similar to the table dependency checks in previous scripts if they are crucial.
--  3. **Redundant `DROP FUNCTION IF EXISTS ... CASCADE;`**:  While not a major issue, the redundant `DROP FUNCTION IF EXISTS ... CASCADE;` at the beginning can be cleaned up similar to the redundant `DROP TABLE` statements identified in previous reviews. **RECOMENDACIÓN: Remove redundant `DROP FUNCTION IF EXISTS ... CASCADE;` statements.**

-- PUNTOS FUERTES:
--  - **Robust Function Design**:  Functions are generally well-designed, modular, and focused on specific tasks.
--  - **Comprehensive Error Handling and Logging**:  Excellent error handling and logging throughout all functions, using `log_system_error()` for consistent error reporting and `RAISE WARNING` for critical issues.
--  - **Security Conscious**:  Appropriate use of `SECURITY DEFINER` and `search_path` for all functions to ensure security and correct context.
--  - **Concurrency Management**:  Explicit locking (`FOR UPDATE`) used in `increment_link_clicks()` and `check_user_quota()` to handle concurrent operations safely.
--  - **Configuration Management**:  Well-developed configuration management functions (`validate_config_value`, `set_user_config`, `bulk_update_config_by_plan`, `reset_user_config_to_plan`) are flexible and auditable.
--  - **Quota Enforcement**:  Quota enforcement triggers (`enforce_bot_quota`, `enforce_collection_quota`, etc.) are implemented correctly using `check_user_quota()`.

-- PRÓXIMO PASO:
--  Please provide the next file, `init_7.sql`, to continue the analysis of the initialization script sequence. `init_6.sql` is a very well-written script defining core business logic with excellent error handling, security considerations and robust function design. The main points for improvement are clarifying the return value choices in exception handling for some functions and ensuring the existence of the assumed utility functions (`get_config_int`, `get_vector_dimension`).  Cleaning up redundant `DROP FUNCTION` statements would also improve script clarity.