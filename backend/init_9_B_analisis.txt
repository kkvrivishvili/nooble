-- Análisis del archivo init_9.sql - Vistas y Comentarios de BD

-- ==============================================
-- ARCHIVO: init_9.sql - Vistas y Comentarios de BD - ANÁLISIS
-- ==============================================
-- Resumen del Propósito:
-- El archivo init_9.sql crea vistas para simplificar consultas complejas y mejorar la documentación de la base de datos mediante comentarios.
-- Todas las vistas utilizan `SECURITY INVOKER` para seguridad RLS.

-- **Observación General Inicial**: El archivo parece bien estructurado y cubre una amplia gama de vistas útiles para análisis, administración y visualización de datos. La intención de `SECURITY INVOKER` es crucial y está consistentemente aplicada. La adición de comentarios es una excelente práctica para documentación.

-- ---------- SECCIÓN 1: VISTAS DE ANÁLISIS DE ACTIVIDAD - ANÁLISIS ----------

-- Eliminar vistas existentes para recrearlas desde cero (CORRECTO y SEGURO)
-- OK: Eliminación segura de vistas existentes usando `DROP VIEW IF EXISTS ... CASCADE`.  Uso de `CASCADE` es apropiado para asegurar que dependencias (otras vistas o objetos dependientes de estas vistas) también sean eliminadas, permitiendo una recreación limpia.

-- Vista para análisis de interacción de usuarios por día (`daily_user_activity`)
-- **OK**: La vista `daily_user_activity` calcula métricas de actividad diaria por usuario, incluyendo conteo de conversaciones, mensajes, tipos de mensajes (usuario/bot), latencia promedio y última actividad.
-- **POSIBLE INCONSISTENCIA/PREGUNTA**:  La vista join `public.messages` y `public.conversations`.  ¿Es intencional que no filtre por `deleted_at IS NULL` en `public.conversations`?  Considerar si se deben incluir solo conversaciones no borradas lógicamente en el análisis por defecto.  **SUGERENCIA ROBUSTA**:  Aclarar si incluir conversaciones borradas es intencional o si se debería añadir `AND c.deleted_at IS NULL` al JOIN. Si la intención es excluir borradas, añadir el filtro.

-- Vista para usuarios con roles (`users_with_roles`)
-- **OK**: La vista `users_with_roles` combina datos de usuarios (`app.users`), roles (`app.user_roles`) y perfiles (`public.profiles`) para ofrecer una vista consolidada.  Incluye información de rol, permisos, metadatos de perfil, etc.  Filtra correctamente por `u.deleted_at IS NULL` para usuarios activos.  Usa `COALESCE(ur.role, 'user')` para rol efectivo, proporcionando un valor por defecto si no hay rol asignado explícitamente.  Uso de `jsonb_build_object` para `role_metadata` es útil.

-- ---------- SECCIÓN 2: VISTAS PARA ANÁLISIS DE BOTS Y DOCUMENTOS - ANÁLISIS ----------

-- Vista para análisis de rendimiento de bots (`bot_performance`)
-- **OK**: La vista `bot_performance` calcula métricas clave para bots, incluyendo conteo de conversaciones, mensajes, rating promedio, feedback, búsquedas vectoriales, latencia, y estadísticas extendidas (distribución de ratings, conteo de colecciones asociadas).  Realiza joins con `app.users`, `public.conversations`, `public.messages`, `app.bot_response_feedback`, `app.vector_analytics` y `public.bot_performance` (esta última tabla no parece creada en scripts previos - **POSIBLE INCONSISTENCIA** -  asumo que se refiere a la *vista* `bot_performance` que se está creando o hay un error de copia/pega - **SUGERENCIA ROBUSTA**: Verificar si `public.bot_performance` es tabla o vista. Si es error, corregir a join con subquery que calcula las métricas de rendimiento o simplemente eliminar el join redundante dentro de la definición de la vista que se está creando). Filtra correctamente por `b.deleted_at IS NULL AND u.deleted_at IS NULL`.

-- Vista para análisis de uso de documentos (`document_usage`)
-- **OK**: La vista `document_usage` proporciona estadísticas detalladas sobre el uso de documentos, incluyendo conteo de chunks, hits en búsquedas, última búsqueda, relevancia promedio y hits recientes (últimos 30 días).  Utiliza joins con `app.documents`, `app.document_collections`, `app.users`, `app.document_chunks` y `app.vector_analytics` (a través de un `LEFT JOIN LATERAL` para obtener datos de `vector_analytics` relacionados).  Filtra por `d.deleted_at IS NULL AND dc.deleted_at IS NULL`.  Cálculo de `recent_hits` con subconsulta y `INTERVAL '30 days'` es correcto.

-- ---------- SECCIÓN 3: VISTAS PARA ADMINISTRACIÓN Y CONFIGURACIÓN - ANÁLISIS ----------

-- Vista para roles de administrador (`admin_users`)
-- **OK**: La vista `admin_users` lista usuarios con rol 'admin', incluyendo información de usuario, rol, permisos, quien otorgó el rol, notas y última conexión.  Realiza joins entre `app.users` (dos veces) y `app.user_roles`.  Filtra por `ur.role = 'admin' AND u.deleted_at IS NULL`.

-- Vista para configuración de usuarios (`user_config_view`)
-- **OK**: La vista `user_config_view` consolida la configuración efectiva por usuario, teniendo en cuenta la jerarquía: configuración de usuario específica > configuración por plan de suscripción > configuración global por defecto. Utiliza `CROSS JOIN` con `app.system_config` para obtener todas las claves de configuración y `LEFT JOIN` con `app.subscriptions`, `app.subscription_plan_config`, `app.user_config` para obtener los valores correspondientes.  Usa `COALESCE` para determinar el `effective_value` y `CASE` para `config_source`. Filtra por `u.deleted_at IS NULL AND (sc.scope = 'user' OR sc.scope = 'subscription')`.  Es una vista compleja pero bien diseñada para gestión de configuración.

-- Vista para administración de configuraciones por plan (`plan_config_view`)
-- **OK**: La vista `plan_config_view` facilita la administración de configuración por plan de suscripción. Utiliza `CROSS JOIN` con una subconsulta que genera los tipos de planes ('free', 'basic', 'premium', 'enterprise') y `app.system_config`.  `LEFT JOIN` con `app.subscription_plan_config` para obtener valores personalizados por plan.  Usa `COALESCE` para obtener el valor efectivo, `CASE` para `is_customized`. Filtra por `sc.scope = 'subscription'`.  Útil para configurar y revisar configuraciones por plan.

-- Vista para subscripciones activas (`active_subscriptions`)
-- **OK**: La vista `active_subscriptions` lista suscripciones activas y en trial, con detalles relevantes como tipo de plan, estado, periodos, pago, renovación, descuentos y si está expirando pronto o ya expiró. Incluye un conteo de historial de cambios en la suscripción (`change_count`). Realiza join con `app.users`. Filtra por `s.status IN ('active', 'trial') AND u.deleted_at IS NULL`.  Ordena por `expiring_soon DESC, s.current_period_end ASC` para facilitar la gestión de suscripciones próximas a vencer.  Cálculos de `expiring_soon` y `expired` son correctos.

-- ---------- SECCIÓN 4: VISTAS PÚBLICAS Y DE COMUNIDAD - ANÁLISIS ----------

-- Vista para bots públicos (comunidad) (`public_bots`)
-- **OK**: La vista `public_bots` lista bots públicos con información relevante para la comunidad, incluyendo nombre, descripción, categoría, tags, popularidad, creador, estadísticas de uso (conteo de colecciones, conversaciones, enlaces), rating promedio y feedback, y última actividad.  Realiza joins con `public.bots`, `app.users`, `public.profiles`, `app.bot_collections`, `public.conversations`, `public.links` y `public.bot_performance` (nuevamente, `public.bot_performance` - **POSIBLE INCONSISTENCIA/PREGUNTA** - similar a `bot_performance` vista anterior). Filtra por `b.is_public = TRUE AND b.deleted_at IS NULL AND u.deleted_at IS NULL`.  Agrupa y ordena por `b.popularity_score DESC, feedback_count DESC` para destacar bots populares y con feedback.  Usa `GREATEST(b.updated_at, MAX(COALESCE(c.last_activity_at, '2000-01-01')))` para `last_activity_at`.

-- Verificación de security_invoker para public_bots (CORRECTO y NECESARIO)
-- **OK**: El bloque `DO $$ ... END $$;` verifica si la vista `public_bots` está configurada con `SECURITY INVOKER`.  Si está configurada como `SECURITY DEFINER` (incorrecto para la intención del script), intenta corregirla a `SECURITY INVOKER` usando `ALTER VIEW ... SET (security_invoker=true)`.  Incluye verificaciones y `RAISE WARNING/NOTICE` para indicar el estado y si se requiere intervención manual. **IMPORTANTE y CORRECTO** para asegurar la seguridad RLS.

-- ---------- SECCIÓN 5: VISTAS PARA ANÁLISIS AVANZADO - ANÁLISIS ----------

-- Vista para resumen de actividad de usuarios (`user_activity_summary`)
-- **OK**: La vista `user_activity_summary` proporciona un resumen completo de la actividad de cada usuario, incluyendo información de usuario, plan, estado de suscripción, conteo de bots, colecciones, documentos, conversaciones, enlaces, vistas de perfil, clicks en enlaces, mensajes (usuario/bot), búsquedas vectoriales, fecha de creación de usuario y última actividad general.  Realiza múltiples `LEFT JOIN` con `app.subscriptions`, `public.profiles`, `public.bots`, `app.document_collections`, `app.documents`, `public.conversations`, `public.links`. Filtra por `u.deleted_at IS NULL`. Agrupa para contar distintos tipos de actividades por usuario.  Usa `GREATEST(...)` para `last_activity`.  Vista muy útil para dashboards administrativos.

-- Vista para métricas de búsqueda vectorial (`vector_search_metrics`)
-- **OK**: La vista `vector_search_metrics` analiza métricas de búsquedas vectoriales por fecha, usuario y bot, incluyendo conteo de búsquedas, latencia (avg, min, max), conteo de resultados promedio, conteo de errores y estrategias de búsqueda utilizadas.  Realiza `LEFT JOIN` con `app.users` y `public.bots`.  Filtra por `va.created_at > NOW() - INTERVAL '30 days'` (análisis de los últimos 30 días). Agrupa por fecha, usuario y bot.  Usa `jsonb_agg(DISTINCT va.search_strategy) FILTER (WHERE va.search_strategy IS NOT NULL)` para listar estrategias únicas.  Útil para monitoreo de rendimiento y calidad de búsquedas vectoriales.

-- Vista para métricas de calidad de bots (`bot_quality_metrics`)
-- **OK**: La vista `bot_quality_metrics` evalúa la calidad de los bots, incluyendo conteo de conversaciones, respuestas de bot, tiempo de respuesta promedio, longitud de respuesta, rating promedio, conteo total de ratings, porcentaje de satisfacción (ratings >= 4 estrellas), categorías de feedback y resultados de búsqueda promedio.  Realiza joins con `public.bots`, `app.users`, `public.conversations`, `public.messages`, `app.bot_response_feedback`, `app.vector_analytics`. Filtra por `b.deleted_at IS NULL AND u.deleted_at IS NULL`. Agrupa por bot.  Cálculo de `satisfaction_percentage` es correcto.  Uso de subconsulta con `jsonb_object_agg` para `feedback_categories` es avanzado y útil.

-- Vista para estado de procesamiento de documentos (`document_processing_status`)
-- **OK**: La vista `document_processing_status` monitorea el estado de procesamiento de documentos, mostrando título, colección, estado, mensaje de error, conteo de chunks, chunks no procesados, fechas de chunks, fechas de documento, tipo de archivo, tamaño y lenguaje.  Realiza joins con `app.documents`, `app.document_collections`, `app.users`, `app.document_chunks`.  Filtra por `d.deleted_at IS NULL AND dc.deleted_at IS NULL`. Agrupa por documento.  Ordena por estado de procesamiento (error > processing > pending > completed) y fecha de actualización para priorizar documentos problemáticos o recientes.  Útil para monitorear el pipeline de ingesta de documentos.

-- ---------- SECCIÓN 6: CREAR VISTAS DE COMPATIBILIDAD - ANÁLISIS ----------

-- Crear vistas de compatibilidad (OK y COMÚN en refactorizaciones)
-- **OK**: La creación de vistas de compatibilidad (e.g., `CREATE OR REPLACE VIEW users AS SELECT * FROM app.users;`) es una técnica común y válida para mantener la compatibilidad con código existente que pueda estar consultando directamente las tablas antiguas (sin esquema `app.`, `public.`).  **ADVERTENCIA**:  Aunque funcionalmente correcto, **esta práctica puede *ocultar* dependencias directas a las tablas base, dificultando futuras refactorizaciones o migraciones de esquema.  SUGERENCIA ROBUSTA**:  Documentar claramente estas vistas de compatibilidad como *TEMPORALES* y con la recomendación de *actualizar el código base* para usar los nombres de esquema completos (`app.users`, `app.user_config`, etc.) lo antes posible.  Eventualmente, estas vistas de compatibilidad deberían ser eliminadas una vez que el código base sea actualizado.**

-- ---------- SECCIÓN 7: VERIFICAR SECURITY INVOKER EN TODAS LAS VISTAS - ANÁLISIS ----------

-- Verificar que todas las vistas tienen SECURITY INVOKER (CORRECTO y CRUCIAL)
-- **OK**: El bloque `DO $$ ... END $$;` verifica **TODAS** las vistas en el esquema `public` (asumiendo que las vistas de compatibilidad también están en `public`) que tienen `securitypolicy = true` (que indica `SECURITY DEFINER`).  Si encuentra alguna, **ADVIERTE** y **INTENTA CORREGIRLAS** a `SECURITY INVOKER`.  Similar a la verificación de `public_bots`, este bloque es **CRÍTICO** para la seguridad RLS y la intención del script.  **SUGERENCIA ROBUSTA**: Extender esta verificación para incluir también las vistas en el esquema `app` (las vistas principales de análisis). Modificar la consulta para `WHERE schemaname IN ('public', 'app') AND securitypolicy = true;`.  Asegurar que **TODAS** las vistas creadas en este script (y quizás en todo el sistema) tengan `SECURITY INVOKER` a menos que haya una razón *muy* específica para usar `SECURITY DEFINER` (que es raro en aplicaciones web con RLS).

-- ---------- SECCIÓN 8: COMENTARIOS DE DOCUMENTACIÓN - ANÁLISIS ----------

-- Agregar comentarios para documentación de tablas principales y vistas (EXCELENTE)
-- **EXCELENTE**: La adición de comentarios a **TABLAS** (`COMMENT ON TABLE ... IS ...;`) y **VISTAS** (`COMMENT ON VIEW ... IS ...;`) es una **PRÁCTICA FUNDAMENTAL** para documentar una base de datos.  Los comentarios proporcionados son **descriptivos y útiles**, explicando el propósito de cada tabla y vista.  La cobertura de comentarios parece **completa**, incluyendo tanto las vistas de análisis/administración como las vistas de compatibilidad.

-- Notificación de finalización (OK)
-- **OK**: El bloque `DO $$ ... END $$;` al final notifica la finalización de la instalación y muestra la versión del esquema y la dimensión vectorial.  Útil para confirmación al ejecutar el script.  Uso de `get_vector_dimension()` (asumir que está definido en scripts anteriores) y consulta a `system_config` es consistente con prácticas anteriores.

-- ==============================================
-- RESUMEN GENERAL DEL ARCHIVO init_9.sql - INCONSISTENCIAS Y SUGERENCIAS ROBUSTAS
-- ==============================================
-- INCONSISTENCIAS Y SUGERENCIAS ROBUSTAS:
--  1. **`public.bot_performance` Confusión**:  La vista `bot_performance` y `public_bots` hacen JOIN con `public.bot_performance`. **SUGERENCIA ROBUSTA**: Verificar si `public.bot_performance` es una tabla (lo cual sería inconsistente con scripts previos) o una errata y debería ser una referencia recursiva a la *vista* `bot_performance` que se está definiendo, o simplemente un error y el JOIN no es necesario/redundante. Clarificar y corregir la definición de las vistas `bot_performance` y `public_bots`.
--  2. **Conversaciones Borradas en `daily_user_activity`**:  La vista `daily_user_activity` no filtra conversaciones borradas (`deleted_at IS NULL` en `public.conversations`). **SUGERENCIA ROBUSTA**: Aclarar si es intencional incluir conversaciones borradas en el análisis de actividad diaria. Si no es intencional, añadir `AND c.deleted_at IS NULL` al `JOIN public.conversations c ON m.conversation_id = c.id` en la definición de `daily_user_activity`.
--  3. **Vistas de Compatibilidad - Documentación y Temporalidad**: Las vistas de compatibilidad (`users`, `user_config`, etc.) son útiles temporalmente, pero pueden generar problemas a largo plazo si el código base no se actualiza. **SUGERENCIA ROBUSTA**:  Añadir **COMENTARIOS EXPLÍCITOS** en el script (ej. justo antes de la SECCIÓN 6) y en los comentarios de las vistas de compatibilidad, indicando que estas vistas son **TEMPORALES** para compatibilidad, y que el **código base debe ser actualizado** para usar los nombres de esquema completos (`app.`, `public.`) para evitar dependencias en estas vistas.  Documentar la intención de *ELIMINAR* estas vistas en un futuro script (`init_XX.sql - Cleanup Compatibility Views`).
--  4. **Verificación de `SECURITY INVOKER` Extendida**: La verificación de `SECURITY INVOKER` se realiza solo en vistas del esquema `public`. **SUGERENCIA ROBUSTA**:  **EXTENDER la verificación** en la SECCIÓN 7 para incluir también las vistas del esquema `app`.  Modificar la consulta en el bloque `DO $$ ... END $$;` para `WHERE schemaname IN ('public', 'app') AND securitypolicy = true;`.  Asegurar que **TODAS** las vistas relevantes tengan `SECURITY INVOKER`.

-- PUNTOS FUERTES:
--  - **Vistas Útiles y Bien Diseñadas**: El script crea un conjunto muy útil y bien diseñado de vistas para análisis, administración y visualización de datos.
--  - **Consistente `SECURITY INVOKER`**:  Utiliza correctamente `SECURITY INVOKER` en todas las vistas, asegurando la aplicación de RLS.  Incluye verificación y corrección automática.
--  - **Excelente Documentación**:  Añade comentarios descriptivos y completos a todas las vistas y tablas documentadas.
--  - **Bien Estructurado**: El script está bien estructurado en secciones lógicas, facilitando la lectura y el mantenimiento.
--  - **Eliminación Segura de Vistas**:  Utiliza `DROP VIEW IF EXISTS ... CASCADE` para una recreación limpia y segura de vistas.

-- PRÓXIMO PASO:
--  Implementar las **SUGERENCIAS ROBUSTAS** para mejorar la consistencia y la documentación (especialmente sobre vistas de compatibilidad y la verificación de `SECURITY INVOKER` extendida).  Una vez corregido, este script `init_9.sql` será una valiosa adición a la suite de inicialización, proporcionando vistas robustas y bien documentadas para la base de datos.  Después de las correcciones, se puede proceder con el análisis del siguiente archivo, `init_10.sql` (si existe).